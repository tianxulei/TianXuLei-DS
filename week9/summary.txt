永不停机的服务程序：
用一个守护进程监控服务器运行状态；
如果服务器出现故障，调度进程将重启服务程序；

一、生成测试数据
二、服务程序的调度
·学习linux信号的基础知识和使用方法；
·学习linux多进程的基础知识和使用方法；
·开发服务程序调度模块；
三、守护进程的实现
·学习linux共享内存的基础知识和使用方法；
·学习linux信号量的基础知识和使用方法；
·开发守护进程模块，与调度模块结合，保证服务程序永不停机；
四、两个常用的小工具
·开发压缩文件模块；
·开发清理历史数据文件模块；

生成测试数据
1）搭建程序框架(运行的参数、说明文档、运行日志)。
2）把全国气象站点参数文件加载到‘站点参数’的容器中。
3）遍历‘站点参数’容器，生成每个站点的观测数据，存放在‘站点观测数据’容器中。
4）把‘站点观测数据’容器中的记录写入文件；

服务程序调度模块
1）周期性的启动后台服务程序
2）常驻内存中的服务程序异常中止，在短时间内重启
查看进程：ps -ef|grep 进程名
killall -9 程序名

守护进程
服务程序由调度程序启动(procctl)
如果服务程序死机(挂起)，守护进程将终止它。
服务程序被终止后，调度程序(procctl)将重新启动它。

服务程序在共享内存中维护自己的心跳信息
开发守护程序，终止已死机的服务程序

linux共享内存
1)调用shmget函数获取或创建共享内存。
2)调用shmat函数把共享内存连接到当前进程的地址空间。
3）调用shmdt函数把共享内存从当前进程中分离。
4)调用shmctl函数删除共享内存。
ipcs -m查看共享内存
ipcrm -m 内存shmid 删除共享内存
CASE信号量头文件（自己查）
ipcs -s查看信号量
ipcrm sem 信号量 删除信号量

写入文件正确方法
创建临时文件
往临时文件写数据
把临时文件改名正式文件

写入文件的内容会先存放在缓冲区，如果这时创建子进程，子进程将也拥有该缓冲区的副本
也会被子进程写入一次，解决方法，用fflush(文件指针)函数将缓冲区先写入内存再创建子进程

signal()使用
signal(int,void):int 信号类型(1-64) void 自定义处理动作
忽略信号：signal(int,SIG_IGN) 忽略int信号
传入信号：killall int name  int 信号类型 name 程序名
ps -ef 查看进程
ps -ef |grep 程序名；
getpid(void)获取进程ID
getppid(void)获取父进程ID

一个现有的进程调用函数fork创建一个新的进程。
子进程和父进程继续执行fork函数后的代码。
fork函数调用一次，返回两次。
子进程返回0，父进程返回子进程的进程ID。子进程是父进程的副本。
子进程获得了父进程的数据空间、堆和栈的副本，不是共享。
父进程中打开的文件描述符也被复制到子进程中.

如果父进程先退出，子进程会成为孤儿进程。
如果子进程先退出，内核向父进程发送SIGCHLD信号，如果父进程不处理这个信号，子进程会成为僵尸进程。
如果子进程在父进程之前终止，内核为每个子进程保留了一个数据结构，包括进程编号、终止状态和使用cpu时间等,父进程如果处理了子进程退出的信息，内核就会释放这个数据结构，如果父进程没有处理子进程退出的信息，内核就不会释放这个数据结构，子进程进程编号就会一直被占用，但是系统可用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程，这就是僵尸进程的危害。
//解决僵尸进程
1.忽略子进程的SIGCHLD信号
2.在父进程中调用wait()等待子进程执行完
3.写一个等待子进程执行的函数（祥见2.8，22：14）

exit函数与析构函数
exit函数不会调用局部对象的析构函数。
exit函数会调用全局部对象的析构函数。
return会调用局部和全局对象的析构函数。

