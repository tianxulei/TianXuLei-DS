这周学了第五六章，把书上的散列表和优先队列的相关代码跟着敲了一遍倒也没有遇到什么大的问题，下面是跟着做的一些笔记，这周做了leetcode的13~24题，相比较上一周，这周也是更加熟练，速度有所提升，遇到的问题通过调试和查找也都能找到解决方法，关于回溯的使用和动态规划还是不太行，只能是看懂了题解，但真要自己想，还是想不出来。相信在往后的练习里面会逐渐熟练。

# 五、散列

## 5.1 一般想法

理想散列表结构是一个固定大小的数组；

将每个关键字映射到数组中的某个位置，这个映射叫“散列函数”；

## 5.2 散列函数

如果关键字是整数，一般直接返回key/numsize；（但如果数组大小字是10，而关键字以0为个位，则效果不好，所以一般保证数组大小是素数）；

如果关键字是字符，则要仔细选择散列函数；（把字符串ASCII码相加）（如果关键字最多八个字符，127*8=1016，这时候选大小10007就是不均匀的；）

一个好的散列函数：num[numsize-i-1]*pow(32,i);

下面是消除位置冲突的方法：

## 5.3 分离链接法

把散列到同一数值的元素保留在一个链表中，其中涉及的插入和删除都与单链表一志。

一般尽量使表大小与元素个数差不多，并保证表大小是素数。

## 5.4 开放定址法

遇到冲突后，找下一个单元知道找到空单元。按照函数h(i)=(Hash(X)+F(i)) mod TableSize,其中F(i)是自定义的冲突解决函数。

标准的删除不能进行，因为会使后面的元素无法被探测到，所以使用懒惰删除。

表大小也要是素数。

#### 5.4.1 线性探测法

F(i)=i;(填装因子最好小于0.5)

缺点：容易形成元素一次聚集，然后每次插入都要找好多次

#### 5.4.2 平方探测法

F(i)=i*i;(填装因子小于0.5)

根据平方定义可以这样写：F(i)=F(i-1)+2i-1(这样就避免了乘法)

如果表有一半是空的，那么新元素总能插入成功。P126有证明

不过也会二次聚集。

#### 5.4.3 双散列

F(i)=i*hash2(X);

hash2(X)是第二个散列函数（这个选的不好将是灾难性的）hash2(X)=R-(XmodR)(R<size)就不错

相比之下，平方探测更优秀。

## 5.5 再散列

前面的探测方法，如果元素多于一半，就会很耗时并且Insert就有可能失败，所以当元素过多时，就建立一个比元素多大约两倍的表，把前面元素迁移过来。

有三种做法：一种是只要元素过半就再散列，另一种是插入失败就再散列，最后是当填充因子达到某一值时再散列。

## 5.6 可扩散列

用于数据量太大而装不进主存的情况



# 六、优先队列（堆）

## 6.1 模型

优先队列是至少支持这两种操作的结构：Insert(插入=入队)，DeleteMin(删除最小者=出队)。

## 6.2 一些简单的实现

一种方法是使用一个简单链表在表头插入，遍历删除最小元；（但是删除代价大N）

一种方法是始终让表保持排序状态；（但是插入代价大N）

一种是使用二叉排序树。（插入和删除都为logN）

## 6.3 二叉堆

同二叉查找树一样，二叉堆具有结构性和堆序性，也和AVL树一样，对堆的一次操作会破坏这两性质，所以堆操作必须等所有性质满足后才终止。

#### 6.3.1 结构性质

堆是一棵完全被填满的二叉树（底层从左到右不一定满）（也叫完全二叉树）

堆可以用数组表示：数组任意位置i上的元素，其左儿子在2i上，右儿子在（2i+1）上，父亲在|i/2|上。（不需要指针了，但是需要提前估计数组长度）

#### 6.3.2 堆序性质

最小节点在根上，任意节点小于它的后裔

#### 6.3.3 基本的堆操作

Insert（上滤）:在堆最后空闲位置建一个空位置，如果插入空位不破坏性质，就插入，否则，把它的父节点跟空位交换，知道可以插入。（注意在0位置放一个最小哑节点，用于终止需要插入根节点的循环）

DeleteMin（下滤）：把根节点删除后，剩一个空穴，把最后的节点拿出来按上面操作插入。

当堆节点是偶数时，有一个节点只有一个儿子，可以通过在最后加一个超级大的哑节点。

#### 6.3.4 其他的堆操作

DecreaseKey(P,dx,H)(降低关键字的值);

IncreaseKey(P,dx,H)(提高关键字的值);

Delete(P,H)(删除)（可以先用DecreaseKey把节点放到头，再用DeleteMin删除）

BuildHeap(H)(构建堆)（先无序构建，然后把每个父节点与其较小儿子交换）

## 6.4 优先队列的应用

事件模拟

## 6.5 d-堆

而二叉堆差不多，只是节点有d个儿子，当优先队列太大装不进主存时，d堆比较有用

## 6.6 左式堆

#### 6.6.1 左式堆的性质

定义：X的零路径长是X到一个没有两个儿子节点的最短路径长。

左式堆中每个节点X，左儿子的零路径长不小于又儿子

#### 6.6.2 左式堆的操作

合并：将具有大的根值的堆与小的堆的右子树合并，再把结果挂到小根值堆的右边。

插入：把单节点当堆，调用合并例程

删除：删除根节点得到两个堆，调用合并例程

## 6.7 斜堆

式左式堆的自调节形式，把除右路径最大节点外的节点都交换左右儿子。

## 6.8 二项队列

#### 6.8.1 二项队列结构

是一堆节点个数为2的n次方的树的集合（但同样大小的树只会出现一次）

#### 6.8.2 二项队列操作

合并：把两个集合中树大小一样的合成一棵树，知道全都不一样为止，得到新的树集合

插入：就是合并一个单节点

删除：一个树的根节点删除后，得到新的树的集合，把它与原集合合并
