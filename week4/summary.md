本周学了第七章和第八章，基本掌握了一系列排序算法的思想，跟着书上的代码写了一遍，但真要自己写不一定写得出来，这些算法都还是能看懂的，但是与之相关的时间复杂度分析真是一个比一个头疼，有些勉强看得懂，但有些看了好久也不会，还有第八章最后的那个Union/Find算法分析是真的没看懂，可能是因为之前的学习只着重于看代码，而忽略了与之相关的数学分析，导致现在一脸懵。之后的学习必须重视一下了。这周由于事情较多，leetcode也是只做了26~34题，之后努力吧。

# 七.排序

### 7.2 插入排序

P循环从0到N-1，把前P个元素排序，这样每次循环，P前面的元素都是排序过的，把第P个元素插入到前面正确的位置即可。（时间复杂度O（N*N））

### 7.4 希尔排序

选择增量序列：h1=|N/2|,h(k+1)=|h(k)/2|;（最坏时间复杂度O（N*N））

Hibbard增量序列：1,3,7,...,pow(2,k)-1;（最坏时间复杂度O（N*根号N））

Sedgewick增量序列：1,5,19,41,109,... {(9·pow(4,i) - 9·pow(2,i)+1)或者(pow(4,i) - 3·pow(2,i)+1)}

（最坏时间复杂度O（pow(N,4/3））

相距为(h1....h(k))的元素依次被排列；

### 7.5 堆排序

先把数组序列变成一个最大堆序列，然后取出根元素放入最后，剩下的堆重新构建，直到取完；

（最坏时间复杂度O（N*log N））

### 7.6 归并排序

用分治法，通过递归分割数组直到数组长度k,对长度为k的数组使用插入排序，然后把已经排序过的两个数组合并。（最坏时间复杂度O（N*log N））

### 7.7 快速排序

找一个枢纽元，遍历数组将元素大小以枢纽元为界分割开，然后继续分割直到分割完；

重点在于怎么选取枢纽元，比较合理的方法是：选取左，右，中间三个值，数值不大不小那个作为枢纽元。（最坏时间复杂度O（N*log N））

###### 7.7.6 快速选择排序

只需要对比要选择的值和枢纽元的位置或大小，就可以只对其中一侧进行操作；

### 7.10 桶式排序

数组A中元素都小于M，建立一个大小为M的数组B，遍历原数组，另B[A[i]]=1，最后把数组B中的元素等于1的位置输出即可；（时间复杂度O（N））

### 7.11 外部排序

把磁带T1上的元素分为大小为M字串，存到两个另外的磁带T3，T4中，从这两个磁带依次个取出一个字串，合并存入另两个磁带T1，T2中，继续依次取出两个合并放入原来两个磁带T3，T4中，直到合并完。

###### 7.11.4 多路合并

就是把上面的两个改为好几个；

###### 7.11.5 多相合并

上面的多路合并需要许多磁带，这个k路合并只要k+1个磁带；下面是合并过程,数字代表顺串个数

T1  0    13  5  0  3  1  0  1

T2  21  8    0  5  2  0  1  0

T3  13  0    8  3  0  2  1  0

###### 7.11.6 替换选择

这是产生顺串的一个方法，依次读入M个元素，把M中第一个元素取出放入顺串，读入下一个元素，如果下一个大于M中最后一个元素，放入M里面，如果小于，则占一个M的位置，直到M的位置全被占完，M里面的元素也作为一个顺串读出；